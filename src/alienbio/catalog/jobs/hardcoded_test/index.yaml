# Hardcoded Test Scenario
# A simple scenario for verifying the simulation loop with hand-defined components.
#
# Chemistry:
#   - Molecules: A, B, C, D
#   - Reactions: A + B -> C (k=0.1), C -> D (k=0.05)
#
# Initial state: A=10, B=10, C=0, D=0
# Expected: A and B deplete, C increases then converts to D

scenario.hardcoded_test:
  chemistry:
    molecules:
      A: {name: "Molecule A", bdepth: 0}
      B: {name: "Molecule B", bdepth: 0}
      C: {name: "Molecule C", bdepth: 1}
      D: {name: "Molecule D", bdepth: 2}

    reactions:
      combine_AB:
        name: "A + B -> C"
        reactants: [A, B]
        products: [C]
        rate: !ev "lambda state: 0.1 * state.get('A', 0) * state.get('B', 0)"

      convert_C:
        name: "C -> D"
        reactants: [C]
        products: [D]
        rate: !ev "lambda state: 0.05 * state.get('C', 0)"

  initial_state:
    A: 10.0
    B: 10.0
    C: 0.0
    D: 0.0

  sim:
    steps: 100

  verify:
    - assert: "state['A'] < 2.0"
      message: "A should be mostly depleted"
    - assert: "state['B'] < 2.0"
      message: "B should be mostly depleted"
    - assert: "state['D'] > 5.0"
      message: "D should have accumulated"

  scoring:
    # Canonical score function - determines pass/fail
    score: !ev "lambda trace: 0.6 * (1.0 - (trace.final.get('A', 0) + trace.final.get('B', 0)) / 20.0) + 0.4 * (trace.final.get('D', 0) / 10.0)"
    # Informational scores
    depletion: !ev "lambda state: 1.0 - (state.get('A', 0) + state.get('B', 0)) / 20.0"
    production: !ev "lambda state: state.get('D', 0) / 10.0"

  passing_score: 0.5
